#!/usr/bin/env python

"""
Created on: 01/02/18
Author: Nikolaos Apostolakos
"""

from __future__ import division, print_function

import os
import sys
import numpy as np
from astropy.table import Table, Column


from nnpz.io import CatalogReader, OutputHandler
import nnpz.io.catalog_properties as prop
import nnpz.io.output_column_providers as ocp
from nnpz.neighbor_selection import *
import nnpz.neighbor_selection.brute_force_methods as bfm
from nnpz.framework import *
from nnpz.weights import *


#
# WARNING:
# This file is a prototype skeleton for the NNPZ framework. Its purpose is to
# help with the interfaces identification. This file will be modified/removed in
# the future in an unpredictable way. You should not consider it as part of the
# NNPZ project.
#


# Read the configuration file
if len(sys.argv) == 1:
    conf_path = os.path.abspath(os.path.dirname(__file__)) # Remove the filename
    conf_path = os.path.dirname(conf_path) # Remove the bin directory
    conf_path = os.path.join(conf_path, 'config', 'nnpz.conf')
else:
    conf_path = sys.argv[1]
exec(open(conf_path).read(), locals())



# Read the data from the files
ref_reader = CatalogReader(ref_cat)
ref_ids = ref_reader.get(prop.ID)
ref_data = ref_reader.get(prop.Photometry(ref_filters))
out_mean_phot_data = ref_reader.get(prop.Photometry(out_mean_phot_filters))
ref_z = ref_reader.get(prop.Column(z_true_col))

target_reader = CatalogReader(target_cat)
target_ids = target_reader.get(prop.ID)
target_data = target_reader.get(prop.Photometry(target_filters, missing_photometry_flags))
target_truez = target_reader.get(prop.Column(z_true_col))
if 'input_size' in locals():
    target_ids = target_ids[:input_size]
    target_data = target_data[:input_size]
    target_truez = target_data[:input_size]

# Construct the neighbor selector
if neighbor_method == 'KDTree':
    selector = KDTreeSelector(neighbors_no).initialize(ref_data)
elif neighbor_method == 'BruteForce':
    selector = BruteForceSelector(bfm.Chi2Distance(), bfm.SmallestSelector(neighbors_no)).initialize(ref_data)
elif neighbor_method == 'Combined':
    selector = EuclideanRegionBruteForceSelector(neighbors_no, batch_size).initialize(ref_data)



# Construct the neighbor finder and build the affected sources map
finder =  AffectedSourcesFinder(selector)
progress_listener = ProgressListener(len(target_data)-1, 'Finding neighbors... ')
affected = finder.findAffected(target_data, progress_listener)



# Compute the weights
weight_phot_provider = ReferenceSamplePhotometry(ref_data)
weight_calculator = LikelihoodWeight()

progress_listener = ProgressListener(len(affected)-1, 'Computing neighbor weights...')
weights = {}
for progress, ref_i in enumerate(affected):
    progress_listener(progress)

    target_i_list = affected[ref_i]
    target_obj = target_data[target_i_list]

    # Get the reference sample object photometry to use for the weight calculation
    ref_obj = np.ndarray(target_obj.shape, dtype=np.float32)
    for i, target_i in enumerate(target_i_list):
        ref_obj[i, :, :] = weight_phot_provider(ref_i, target_i)

    # Compute the weights. Note that we mask out the bands which are marked as NaN
    nan_masks = [np.logical_not(np.isnan(target_obj_i[:,0])) for target_obj_i in target_obj]
    weights[ref_i] = [weight_calculator(ref_obj_i[mask_i,:], target_obj_i[mask_i,:]) for ref_obj_i, target_obj_i, mask_i in zip(ref_obj, target_obj, nan_masks)]



# Create the output handler
output = OutputHandler()
cat_to_copy = target_reader.getAsAstropyTable()
if 'input_size' in locals():
    cat_to_copy = cat_to_copy[:input_size]
output.addColumnProvider(ocp.FullCatalogCopy(cat_to_copy))
output.addColumnProvider(ocp.MeanTrueRedshift(len(target_ids), ref_z))
output.addColumnProvider(ocp.NeighborList(len(target_ids), ref_ids))
output.addColumnProvider(ocp.TrueRedshiftPdz(len(target_ids), ref_z, 0, 6, 601))
output.addColumnProvider(ocp.MeanPhotometry(len(target_ids), [f[0] for f in out_mean_phot_filters], out_mean_phot_data))

# Loop through the maps and add the contributions to the output
progress_listener = ProgressListener(len(affected)-1, 'Adding contributions to output...')
for progress, ref_i in enumerate(affected):
    progress_listener(progress)
    for target_i, w in zip(affected[ref_i], weights[ref_i]):
        output.addContribution(ref_i, target_i, w)

# Create the output catalog
output.save(output_file)
print('Created file {}'.format(output_file))
