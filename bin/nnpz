#!/usr/bin/env python

"""
Created on: 01/02/18
Author: Nikolaos Apostolakos
"""

from __future__ import division, print_function

import os
import sys
import numpy as np

import nnpz.io.output_column_providers as ocp
from nnpz.framework import *
from nnpz.weights import *
from nnpz.config import ConfigManager
from nnpz.utils import Logging
from nnpz import NnpzFlag


#
# WARNING:
# This file is a prototype skeleton for the NNPZ framework. Its purpose is to
# help with the interfaces identification. This file will be modified/removed in
# the future in an unpredictable way. You should not consider it as part of the
# NNPZ project.
#


# Read the configuration file and parse the user parameters

usr_args = sys.argv[1:]

# First we check if the first parameter is a configuration file. If it is, we
# use the options in it. Otherwise we find the default config file.
if len(usr_args) != 0 and os.path.isfile(usr_args[0]):
    conf_path = sys.argv[1]
    usr_args = usr_args[1:]
else:
    conf_path = os.path.abspath(os.path.dirname(__file__)) # Remove the filename
    conf_path = os.path.dirname(conf_path) # Remove the bin directory
    conf_path = os.path.join(conf_path, 'config', 'nnpz.conf')
args = {}
exec(open(conf_path).read(), args)

# Now go through the options given by the user at the command line and add then
# to the args parameter
for i in range(0, len(usr_args), 2):
    key = usr_args[i]
    value = usr_args[i+1]
    if not key.startswith('--'):
        print('Invalid option: {}'.format(key))
        exit(-1)
    key = key[2:]
    try:
        args[key] = eval(value)
    except:
        # If the evaluation failed use the argument as a string
        args[key] = value


# If the user has set a log level use it. Otherwise use the default.
if 'log_level' in args:
    Logging.enableStdErrLogging(args['log_level'])
else:
    Logging.enableStdErrLogging()

logger = Logging.getLogger('Main')
logger.debug('Configuration file: {}'.format(conf_path))
logger.debug('Running NNPZ with the following options:')
for key in args:
    if key.startswith('_'):
        continue
    value = args[key]
    logger.debug('    {} : {}'.format(key, value))
logger.debug('')

# Create the object which handles the user parameters
conf_manager = ConfigManager(args)


# Read the reference sample data
ref_ids = conf_manager.getObject('reference_ids')
ref_data = conf_manager.getObject('reference_phot_data')

# Read the target catalog data
target_ids = conf_manager.getObject('target_ids')
target_data = conf_manager.getObject('target_phot_data')

# Get the neighbor selector and initialize it
selector = conf_manager.getObject('neighbor_selector').initialize(ref_data)


# Construct the array which keeps the flags objects of all the target sources
result_flags = [NnpzFlag() for i in range(len(target_data))]


# Construct the neighbor finder and build the affected sources map
finder =  AffectedSourcesFinder(selector)
progress_listener = ProgressListener(len(target_data)-1, 'Finding neighbors... ')
affected = finder.findAffected(target_data, result_flags, progress_listener)


# Compute the weights
weight_phot_provider = ReferenceSamplePhotometry(ref_data)
weight_calculator = LikelihoodWeight()

progress_listener = ProgressListener(len(affected)-1, 'Computing neighbor weights...')
weights = {}
for progress, ref_i in enumerate(affected):
    progress_listener(progress)

    target_i_list = affected[ref_i]
    target_obj = target_data[target_i_list]
    target_flags = [result_flags[i] for i in target_i_list]

    # Get the reference sample object photometry to use for the weight calculation
    ref_obj = np.ndarray(target_obj.shape, dtype=np.float32)
    for i, target_i in enumerate(target_i_list):
        flag = result_flags[target_i]
        ref_obj[i, :, :] = weight_phot_provider(ref_i, target_i, flag)

    # Compute the weights. Note that we mask out the bands which are marked as NaN
    nan_masks = [np.logical_not(np.isnan(target_obj_i[:,0])) for target_obj_i in target_obj]
    weights[ref_i] = [weight_calculator(ref_obj_i[mask_i,:], target_obj_i[mask_i,:], flag) for ref_obj_i, target_obj_i, mask_i, flag in zip(ref_obj, target_obj, nan_masks, target_flags)]



# Get the output handler
output = conf_manager.getObject('output_handler')

# Loop through the maps and add the contributions to the output
# Note that we iterate the affected map in increasing order of the reference
# sample indices. This is done to use as much the cache of the disk, by accessing
# the PDZs and the SEDs sequentially.
progress_listener = ProgressListener(len(affected)-1, 'Adding contributions to output...')
for progress, ref_i in enumerate(sorted(affected)):
    progress_listener(progress)
    for target_i, w in zip(affected[ref_i], weights[ref_i]):
        output.addContribution(ref_i, target_i, w, result_flags[target_i])

# Create the output catalog
output_file = conf_manager.getObject('output_file')
output.save(output_file)
print('Created file {}'.format(output_file))
